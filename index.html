<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Numerical Aperture Tool</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: monospace; }
        
        /* Overlay for PC users (Instructions) */
        #overlay {
            position: absolute; top: 10px; left: 10px; color: #00ff00; 
            background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00ff00;
            pointer-events: none; user-select: none; z-index: 999;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h3>VR Numerical Aperture (NA)</h3>
        <p>1. Click "ENTER VR" below</p>
        <p>2. <b>Right Trigger</b>: Increase NA (Widen)</p>
        <p>3. <b>Left Trigger</b>: Decrease NA (Narrow)</p>
        <p><i>Note: Requires WebXR headset (Quest, Vive, etc.) or Chrome WebXR Emulator extension.</i></p>
    </div>

    <!-- We use ES Modules from unpkg.com -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
        import { VRButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/VRButton.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        scene.fog = new THREE.FogExp2(0x101010, 0.1);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        // Default position for debugging on non-VR screen
        camera.position.set(0, 1.6, 2);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true; // IMPORTANT: Enables VR
        document.body.appendChild(renderer.domElement);

        // Add the VR Button to the DOM
        document.body.appendChild(VRButton.createButton(renderer));

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 1);
        spotLight.position.set(0, 5, 0);
        scene.add(spotLight);

        // Floor Grid
        const grid = new THREE.GridHelper(20, 20, 0x444444, 0x111111);
        scene.add(grid);

        // --- 2. OBJECTS SETUP ---
        const benchGroup = new THREE.Group();
        benchGroup.position.set(0, 1.3, -1.0); 
        scene.add(benchGroup);

        // Fiber Housing (The metal cylinder)
        const fiberGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 32);
        const fiberMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
        const fiberHousing = new THREE.Mesh(fiberGeo, fiberMat);
        fiberHousing.rotation.x = Math.PI / 2;
        fiberHousing.position.z = -0.5;
        benchGroup.add(fiberHousing);

        // Fiber Core (The glowing tip)
        const coreGeo = new THREE.CircleGeometry(0.04, 32);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.z = 0.001; 
        benchGroup.add(core);

        // Light Cone Geometry
        const coneHeight = 3.0; 
        const coneGeo = new THREE.ConeGeometry(1, coneHeight, 64, 1, true); // Radius 1 (base), scaled later
        coneGeo.translate(0, -coneHeight/2, 0); // Move pivot to tip (top of cone)
        coneGeo.rotateX(-Math.PI / 2); // Rotate to point along Z axis
        
        const coneMat = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00, 
            transparent: true, 
            opacity: 0.3, 
            side: THREE.DoubleSide, 
            blending: THREE.AdditiveBlending, 
            depthWrite: false
        });
        const lightCone = new THREE.Mesh(coneGeo, coneMat);
        benchGroup.add(lightCone);

        // Screen (Where the light hits)
        const screenGeo = new THREE.PlaneGeometry(4, 4);
        const screenMat = new THREE.MeshBasicMaterial({ 
            color: 0x222222, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.5 
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.z = coneHeight;
        benchGroup.add(screen);

        // The Light Spot on the screen
        const spotGeo = new THREE.CircleGeometry(1, 64);
        const spotMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const spot = new THREE.Mesh(spotGeo, spotMat);
        spot.position.z = 0.01; // Slightly in front of screen to prevent Z-fighting
        screen.add(spot);

        // --- 3. DASHBOARD UI (Canvas in 3D) ---
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const uiTexture = new THREE.CanvasTexture(canvas);
        const uiPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(1.0, 1.0),
            new THREE.MeshBasicMaterial({ map: uiTexture, transparent: true })
        );
        uiPlane.position.set(0, 1.2, -0.5);
        benchGroup.add(uiPlane);

        function updateDashboard(angleDeg, naVal) {
            // Background
            ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
            ctx.fillRect(0, 0, 512, 512);
            
            // Border
            ctx.strokeStyle = "#00ffff"; 
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, 512, 512);

            // Text
            ctx.font = "bold 40px Consolas"; 
            ctx.fillStyle = "#ffffff"; 
            ctx.textAlign = "center";
            ctx.fillText("NUMERICAL APERTURE", 256, 60);

            ctx.font = "30px Consolas"; 
            ctx.fillStyle = "#aaaaaa";
            ctx.fillText("NA = n * sin(θ)", 256, 120);

            // FIX: Added backticks for template literals
            ctx.fillStyle = "#ffaa00"; 
            ctx.font = "bold 90px Consolas";
            ctx.fillText(`NA: ${naVal.toFixed(2)}`, 256, 250);

            ctx.fillStyle = "#ffffff"; 
            ctx.font = "50px Consolas";
            ctx.fillText(`θ: ${angleDeg.toFixed(1)}°`, 256, 340);

            uiTexture.needsUpdate = true;
        }

        // --- 4. CONTROLLER LOGIC ---
        // Controller 0: Usually Right Hand
        // Controller 1: Usually Left Hand
        const controller0 = renderer.xr.getController(0);
        const controller1 = renderer.xr.getController(1);
        scene.add(controller0);
        scene.add(controller1);

        // Add visual rays to controllers so user can see hands
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
        const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x555555 }));
        line.scale.z = 5;
        controller0.add(line.clone());
        controller1.add(line.clone());

        // State variables
        let isRightPressed = false;
        let isLeftPressed = false;
        let thetaDeg = 15; // Starting angle

        // Event Listeners for VR Triggers ('select' event)
        controller0.addEventListener('selectstart', () => { isRightPressed = true; });
        controller0.addEventListener('selectend', () => { isRightPressed = false; });
        
        controller1.addEventListener('selectstart', () => { isLeftPressed = true; });
        controller1.addEventListener('selectend', () => { isLeftPressed = false; });

        // --- 5. ANIMATION LOOP ---
        renderer.setAnimationLoop(() => {
            // Logic to change angle based on input
            // Right Trigger increases angle, Left Trigger decreases
            if(isRightPressed && thetaDeg < 85) thetaDeg += 0.5;
            if(isLeftPressed && thetaDeg > 2) thetaDeg -= 0.5;

            // Math Calculation
            const thetaRad = thetaDeg * (Math.PI / 180);
            // NA = n * sin(theta). Assuming air (n=1)
            const NA = 1.0 * Math.sin(thetaRad); 

            // Visual Updates
            // tan(theta) = Opposite/Adjacent -> Radius = Length * tan(theta)
            const requiredRadius = coneHeight * Math.tan(thetaRad);
            
            // Scale X and Y (which correspond to the circle radius in our rotated cone)
            lightCone.scale.set(requiredRadius, requiredRadius, 1);
            
            // Scale the spot on the screen to match
            spot.scale.set(requiredRadius, requiredRadius, 1);
            
            // Update the text canvas
            updateDashboard(thetaDeg, NA);

            renderer.render(scene, camera);
        });

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
